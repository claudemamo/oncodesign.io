<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postgresql on On Code &amp; Design</title>
    <link>http://oncodesign.io/tags/postgresql/</link>
    <description>Recent content in Postgresql on On Code &amp; Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Apr 2017 09:33:52 +0200</lastBuildDate>
    
	<atom:link href="http://oncodesign.io/tags/postgresql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Paging One-to-Many Results in SQL</title>
      <link>http://oncodesign.io/2017/04/22/paging-one-to-many-results-in-sql/</link>
      <pubDate>Sat, 22 Apr 2017 09:33:52 +0200</pubDate>
      
      <guid>http://oncodesign.io/2017/04/22/paging-one-to-many-results-in-sql/</guid>
      <description>Pagination in databases, the division of query results into manageable subsets, is often implemented in terms of SQL constructs like LIMIT or FETCH FIRST, and OFFSET. This works well when the result is compromised of one-to-one relationships. On the other hand, hypothesise what happens if the relationship is a one-to-many as in the following DDL [1]:
 An author can write n books as expressed in the foreign key constraint declared on Book&amp;rsquo;s authorId column.</description>
    </item>
    
    <item>
      <title>Better 0-Downtime Deployment with a Database using Triggers (&amp; Flyway)</title>
      <link>http://oncodesign.io/2016/09/23/better-zero-downtime-deployment-with-a-database-using-triggers-and-flyway/</link>
      <pubDate>Fri, 23 Sep 2016 14:29:41 +0200</pubDate>
      
      <guid>http://oncodesign.io/2016/09/23/better-zero-downtime-deployment-with-a-database-using-triggers-and-flyway/</guid>
      <description>This summer I was initiated into the arcane art of zero downtime deployment. A vendor, for better or worse, mandated that application releases are deployed on their platform without sacrificing the service&amp;rsquo;s availability. Achieving no downtime for a stateless application is more or less straightforward. Take down the application server, upgrade the application, and restart the server; repeat per replica. Bringing a database into the picture complicates the process because alterations to the database schema or data must not break the older application which is live until the upgrade is over (i.</description>
    </item>
    
  </channel>
</rss>