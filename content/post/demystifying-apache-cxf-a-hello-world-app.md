+++
title = "Demystifying Apache CXF: A Hello World App"
date = 2012-12-19T07:56:00Z
updated = 2013-08-01T11:08:22Z
tags = ["CXF", "JAX-WS", "How-to"]
blogimport = true
[author]
	name = "Claude"
	uri = "https://www.blogger.com/profile/06379003436141860057"
+++

"<i>CXF scares the sh**t out of me!</i>".&nbsp;This was a client's comment during our discussion on&nbsp;<a href="http://cxf.apache.org/" target="_blank">Apache CXF</a> and I think it's a feeling shared by many. This feeling usually arises from a complaint I hear on CXF: the lack of documentation. However, I suspect that CXF's flexibility confuses numerous newbies and therefore contributes to the negative feelings towards it.&nbsp;The bad news is that, for some, it's hard to live without CXF. Popular open source software such as Apache Camel, Mule, and JBoss AS rely on CXF for their out-of-the-box web service support.<br /><br />With the hope of increasing the understanding of Apache CXF, I've decided to publish the first of a series of how-tos. Each how-to demonstrates how to accomplish a particular task in CXF. For example, in this one I'll show how to publish a SOAP&nbsp;over HTTP&nbsp;Web Service.&nbsp;Throughout the how-tos, I will assume you have knowledge of basic Java and web services (e.g., SOAP, WSDL, REST). I will also assume you have knowledge of Maven. Maven is the tool I use for setting up dependencies, build and run the apps described by the how-tos. Don't worry, I'll make the apps available on <a href="https://github.com/claudemamo" target="_blank">GitHub</a> :-).<br /><br />Before getting our hands dirty with this how-to, I'll give a 10,000 foot view of Apache CXF for those who are new to the framework. The following is its definition taken from CXF's official website:<br /><br /><div class="p1">"<i>Apache CXF is an open source services </i>[Java]<i> framework. CXF helps you </i><b style="font-style: italic;">build and develop services</b><i> using </i><b style="font-style: italic;">frontend programming APIs</b><i>, like JAX-WS and JAX-RS. These services can speak a variety of </i><b style="font-style: italic;">protocols</b><i> such as SOAP, XML/HTTP, RESTful HTTP, or CORBA and work over a variety of </i><b style="font-style: italic;">transports</b><i> such as HTTP, JMS or JBI.</i>"</div><div class="p1"><br /></div><div class="p1">In other words, with CXF, we can mix and match frontend APIs [1], protocols and transports to implement a service. For instance, we can instruct CXF to expose a Java application's interface as a WSDL and have the app talk with clients using CORBA over IIOP. But CXF is not just used to "build and develop services". We can also use CXF to build and develop service clients such as a SOAP consumer [2].<br /><br />Now that we have an idea of what CXF is, let's follow the <a href="https://github.com/claudemamo/cxf-howto-1" target="_blank">first how-to</a>: Publish a&nbsp;SOAP over HTTP Web Service&nbsp;that takes in a string and returns "Hello" with the input string appended to it.<br /><br />I have the following class:<br /><br /><script src="https://gist.github.com/claudemamo/4306173.js?file=HelloWorldImpl(1).java"></script>I want the class&nbsp;to be exposed to the outside world as a Web Service. That is, I want to have:<br /><ul><li>a WSDL that reflects the class interface and is accessible to clients</li></ul><ul><li>SOAP requests translated into object method invocations and method results translated into SOAP replies.</li></ul><div><br />With CXF, different approaches exist for doing the above. In this post, I'll cover the standard approach and leverage CXF's support for JAX-WS. In the Java world, <a href="http://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services" target="_blank">JAX-WS</a> is a spec for mapping a class to a SOAP Web Service. I map <i>HelloWorldImpl</i> by adding annotations to it:</div><br /><script src="https://gist.github.com/claudemamo/4306173.js?file=HelloWorldImpl(2).java"></script>The JAX-WS annotations in the class instruct the JAX-WS provider (i.e., CXF) to:<br /><ul><li>Expose HelloWorldImpl as a Web Service (@WebService)</li><li>Set the parameter name in the WSDL to "text" (@WebParam(name = "text")) [3].</li></ul><br />The next step is to launch the Web Service so I can process SOAP requests.&nbsp;One strategy for launching the Web Service is to deploy the app onto a web container such as Tomcat. But this requires quite a bit of setup. I'd like to keep things simple for this first how-to. JAX-WS provides an easy way for launching the Web Service from within your application [4]:<br /><br /><script src="https://gist.github.com/claudemamo/4306173.js?file=Sever.java"></script><i>Endpoint.publish(...)</i> tells the JAX-WS provider to start an embedded web server (<a href="https://www.eclipse.org/jetty/" target="_blank">Jetty</a> for CXF) on a different thread. I give the method a URL from where the Web Service will be operating on&nbsp;and the class to be published as a Web Service.<br /><br />What happens if I try to run the app without including the CXF libraries in the Java classpath? It will actually run without a hitch, that is, the Web Service will start up.&nbsp;The problem&nbsp;is I won't be using CXF as the JAX-WS provider. If you're using the Oracle JDK, <a href="http://jax-ws.java.net/" target="_blank">JAX-WS RI</a> is the default JAX-WS provider since it comes bundled with the JDK. Changing from JAX-WS RI to CXF is just a matter of declaring two CXF dependencies in the POM file:<br /><br /><script src="https://gist.github.com/claudemamo/4306173.js?file=pom.xml"></script>To test the Web Service, from your console, goto the project's root directory and type:<br /><br /><script src="https://gist.github.com/claudemamo/4306173.js?file=run.sh"></script> <div style="text-align: justify;">Accessing <i><a href="http://localhost:9000/helloWorld?wsdl">http://localhost:9000/helloWorld?wsdl</a></i> from your browser should bring up the Web Service's WSDL. <br /><span style="font-family: Times, Times New Roman, serif; font-size: small;"><span class="num"><br /></span></span><span style="font-family: Times, Times New Roman, serif; font-size: small;"><span class="num">1:&nbsp;</span><span style="text-align: justify;">A frontend programming API is an API for mapping your application interface (e.g., Java interface) to a different interface (e.g., RESTful).</span></span><br /><span style="font-family: Times, Times New Roman, serif; font-size: small;">2: Funnily enough, this isn't mentioned in the definition.</span><br /><span style="font-family: Times, Times New Roman, serif; font-size: small;"><span class="num">3:&nbsp;</span><span style="text-align: justify;"><a href="http://cxf.apache.org/faq.html#FAQ-Thepartsinmygeneratedwsdlhavenamesoftheform%22arg0%22%2C%22arg1%22%2C...Whydon%27ttheparts%28andJavageneratedfromthem%29usetheniceparameternamesItypedintotheinterfacedefinition%3F">@WebParam is required</a> because a JAX-WS provider cannot deduce the parameter name from the compiled code in some situations.</span></span><br /><span style="font-family: Times, Times New Roman, serif; font-size: small;">4: Note that I'm not saying this is the suggested approach for a production environment. Even though it takes more time to setup, a web container offers several advantages over an embedded approach.</span></div></div>
