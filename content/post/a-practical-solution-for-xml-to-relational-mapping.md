+++
title = "A Practical Solution for XML-to-Relational Mapping"
date = 2012-11-14T21:09:00Z
updated = 2013-12-10T13:34:10Z
tags = ["Hyperjaxb3", "JPA", "Hibernate", "JAXB"]
blogimport = true
[author]
	name = "Claude"
	uri = "https://www.blogger.com/profile/06379003436141860057"
+++

<div style="text-align: justify;">A challenge in the field of integration is persisting&nbsp;to a relational database&nbsp;the contents of an XML document [1].&nbsp;At first glance, this might seem like a no-brainer. Create a database table where each column maps to an element defined in the XML document's XSD. Then write an INSERT SQL statement that iterates through each element of the XML document.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">But what if an XML element has attributes? What about elements containing other elements? How will we deal with elements that may occur multiple times within an element? What if element order is important? And if the XML schema is&nbsp;recursive? Yikes!&nbsp;<a href="http://homepages.inf.ed.ac.uk/wenfei/qsx/reading/xmltosqlsurvey.pdf" target="_blank">As other people</a> have pointed out, XML-to-relational mapping is not a trivial problem and the solution mentioned above will&nbsp;only work for the simplest of XSDs.</div><div style="text-align: justify;"><br />In addition to a complex XML schema, we have another issue to consider: the size of the XSD. We could be tempted to write the mappings (i.e., the SQL) for an XSD that consists of a small no. of element definitions.&nbsp;On the other hand, writing the mappings for a 50 KB XSD is suicidal.<br /><br />What we need is a library that hides from us the&nbsp;intricacies&nbsp;of persisting XML documents.&nbsp;In the Java space, attempts have been made at producing an XML-to-relational mapper. For instance, Hibernate 3 has a little known experimental feature were <i><a href="http://docs.jboss.org/hibernate/orm/3.3/reference/en/html/xml.html" target="_blank">EntityMode.DOM4J</a></i> is used to&nbsp;persist and retrieve XML, much in the same way you would do with POJOs. Unfortunately, this feature was considered to have too many "holes" and <a href="https://hibernate.atlassian.net/browse/HHH-6879" target="_blank">removed from Hibernate 4</a>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">An alternative to Hibernate 3's&nbsp;<i>EntityMode.DOM4J</i> feature&nbsp;is <a href="http://shrex.sourceforge.net/" target="_blank">Shrex</a>: an open source prototype mapper originating from a <a href="http://www.cs.utah.edu/~juliana/pub/shrex-widm2004.pdf" target="_blank">paper's thesis</a>. I think Shrex has potential. With a few code changes to the prototype, I generated a database schema from a non-trivial XSD and "shredded" an XML document into relations. Having said that, I don't think Shrex is a practical solution. First off, Shrex's&nbsp;code base is un-maintained. To make things worse, it's devoid of community support. Therefore, taking the plunge with Shrex means that you'll be the one maintaining it. Secondly, Shrex was developed in an academic environment and, to my knowledge, never used in the wild. You'll probably have to make significant changes to the code base so that Shrex can&nbsp;meet your mapping requirements.</div><div style="text-align: justify;"><br />Till now, I've presented software that do the XML-relational conversion in one step. Yet, the lack of support makes these mappers impractical&nbsp;for a project that must meet a tight deadline. The Java EE &nbsp;platform provides well supported standards for:&nbsp;</div><div style="text-align: justify;"><ul><li>Binding XML documents to objects called&nbsp;<a href="http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding" target="_blank">JAXB</a>,&nbsp;and&nbsp;</li></ul><ul><li>Persisting objects into a relational store called&nbsp;<a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a>.&nbsp;</li></ul><br />Leveraging JAXB and JPA, we could&nbsp;use objects as a go-between for persisting XML documents [2].&nbsp;However, JAXB and JPA require Java classes for holding the XML data. Moreover, these classes must be annotated with mapping instructions. Writing the classes and annotations is undoable for a large or complex XSD. But generating them is doable and we can do it using an awesome <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/xjc.html" target="_blank">XJC</a> extension developed by&nbsp;Aleksei Valikov:&nbsp;<a href="http://confluence.highsource.org/display/HJ3/Home" target="_blank">Hyperjaxb3</a>.&nbsp;</div><div style="text-align: justify;"><br /><div class="separator" style="clear: both; text-align: center;"><img style="max-width:70%" border="0" src="http://3.bp.blogspot.com/-fS7zw5ZSn7w/UKP5AG7edLI/AAAAAAAAAEc/APWlQGNcwYw/s640/xml-object-relational.png" /></div><br /><br />Given an XSD,&nbsp;Hyperjaxb3&nbsp;generates POJO classes annotated with JAXB and JPA. Let me demonstrate how to use Hyperjaxb3 by walking you through a Maven project I've developed and made <a href="https://github.com/claudemamo/hyperjaxb3-example" target="_blank">available</a> on GitHub.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">The following is the XSD of the XML documents I &nbsp;want to persist:</div><div style="text-align: justify;"><br /><script src="https://gist.github.com/claudemamo/4052116.js?file=mails.xsd"></script></div><div style="text-align: justify;"></div><div style="text-align: justify;">If you're careful, you'll note that the complex type&nbsp;<i>envelopeType</i> has an element and attribute with identical names: "from". Running&nbsp;Hyperjaxb3 on this schema will generate an <i>EnvelopeType</i>&nbsp;class containing two getters and setters with the same method names; illegal under the rules of Java. To prevent a name collision, I wrote a JAXB binding file:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><script src="https://gist.github.com/claudemamo/4052116.js?file=mails.xjb"></script></div><div style="text-align: justify;"></div><div style="text-align: justify;">In the binding file, aside from the name customisation, I instruct&nbsp;Hyperjaxb3 to generate classes:</div><div style="text-align: justify;"></div><ol><li style="text-align: justify;">that follow the JPA spec, and</li><li style="text-align: justify;">have the package name <i>org.opensourcesoftwareandme</i>.</li></ol><div style="text-align: justify;">In the project's POM, I configure Maven to execute the&nbsp;Hyperjaxb3 plugin during the build:</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><script src="https://gist.github.com/claudemamo/4052116.js?file=pom-1.xml"></script></div><div style="text-align: justify;"></div><div style="text-align: justify;">The plugin, by default, scans "src/main/resources" for any XSDs and generates classes from them.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">In addition to the plugin, I declare the dependencies for the project:</div><div style="text-align: justify;"><br /><script src="https://gist.github.com/claudemamo/4052116.js?file=pom-2.xml"></script></div><div style="text-align: justify;"></div><div style="text-align: justify;">The dependencies to note are:</div><div style="text-align: justify;"></div><ol><li style="text-align: justify;"><i>hyperjaxb3-ejb-runtime</i>: provides utility methods for (de)serialization, retrieving the persisted ID, etc...&nbsp;</li><li><span style="text-align: justify;"><i>hibernate-entitymanager</i>: the JPA provider which in this case is Hibernate</span></li><li><span style="text-align: justify;"><i>derby</i>: the database used for testing</span></li></ol><div style="text-align: justify;">To test the mapping, I wrote a JUnit test case:</div><div style="text-align: justify;"><br /><script src="https://gist.github.com/claudemamo/4052116.js?file=Hyperjaxb3ExampleTestCase.java"></script>In a few words, the test case:</div><div style="text-align: justify;"></div><ol><li style="text-align: justify;">Creates a map and populates it with configuration settings that tell Hibernate the database to use for persisting the XML document and how it should be set up.&nbsp;</li><div style="text-align: justify;"><br /></div><li style="text-align: justify;">Initialises&nbsp;Hibernate with the configuration settings</li><div style="text-align: justify;"><br /></div><li style="text-align: justify;">Uses H<span style="text-align: left;">yperjaxb3's utility classes,&nbsp;</span>JAXBContextUtils &nbsp;and JAXBElementUtils, to deserialize the XML test document mails.xml:</li><div style="text-align: justify;"><br /></div><li style="text-align: justify;">Tells Hibernate to persist the object</li><div style="text-align: justify;"><br /></div><li style="text-align: justify;">Retrieves the persisted object and asserts that the data content is the same as in the XML doc.</li></ol><div style="text-align: justify;">You can run Hyperjaxb3 by entering "mvn test" from your console, which will run the test as well. The generated classes are found in the <i>target</i> folder.<br /><br />I'm very&nbsp;interested&nbsp;in seeing other alternatives for persisting XML documents to a relational database.&nbsp;I'd also love to know if persisting XML documents with Hyperjaxb3&nbsp;would work for your project, and if not, why.<br /><br /></div><div style="text-align: justify;"><span style="font-family: Times, Times New Roman, serif; font-size: small;"><span class="num">1:&nbsp;</span><span style="text-align: justify;">The wisdom of employing a relational database instead of a document store is debatable.</span></span><br /><span style="font-family: Times, Times New Roman, serif; font-size: small;">2: Note that this isn't a general solution for persisting XML documents.</span></div>
