+++
title = "The Trials of Smooks"
date = 2014-09-16T17:28:00Z
updated = 2015-11-11T16:23:45Z
tags = ["Java", "Smooks"]
blogimport = true 
[author]
	name = "Claude"
	uri = "https://www.blogger.com/profile/06379003436141860057"
+++

The fact that I'm a hard to please guy explains why I rarely show appreciation for a tool. I easily get frustrated when a tool fails to meet the challenges it's meant to solve. <a href="http://www.smooks.org/" target="_blank">Smooks</a> is one of the few tools I appreciate. It's an invaluable transformation framework in the integrator's arsenal. On a project I was on, I threw at Smooks [1] all manner of challenges, and one after another, Smooks overcame them without giving up a key requirement: <b>maintaining a low memory overhead during transformation</b>. A shoutout to <a href="http://www.smooks.org/mediawiki/index.php?title=Smooks_Team" target="_blank">Tom Fennelly and his team</a> for bringing to us such a fantastic tool.<br /><br /><h3><b>Trial I</b></h3><br />The initial challenge I brought to Smooks was about taking a tilde delimited CSV file and map its records to POJOs:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=products.csv"></script>You can see the file has an unorthodox header in addition to a footer. Using Smooks's built-in CSV <b>reader</b>, I wrote concisely the Smooks config doing the mapping to POJOs:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=csv-to-pojos.xml"></script>What's happening under the covers, and in general, is that the reader pulls data from a <b>source</b> (e.g., <i>java.io.InputStream</i>) to go on to produce a stream of SAX events. The reader I'm using above is expecting the source data to be structured as CSV and to consist of 4 columns. Let's make things more concrete. Reading from the <i>products.csv</i> file, the reader produces the following XML stream [2]:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=products-xml-stream.xml"></script>Listening to the stream of SAX events is the <b>visitor</b>. A visitor listens to specific events from the stream to fire some kind of behaviour, typically transformation. With the&nbsp;<i>singleBinding</i>&nbsp;element in the&nbsp;<i>csv-to-pojos.xml</i> config, the CSV reader pre-configures a JavaBean&nbsp;visitor to listen for&nbsp;<i>csv-record</i> elements. On intercepting this element, the JavaBean visitor instantiates a&nbsp;<i>org.ossandme.Product</i>&nbsp;object and binds its properties to <i>csv-record</i>'s children element content. You'll notice that I left&nbsp;<i>Product's&nbsp;</i>target properties unspecified in the config. The CSV reader assumes&nbsp;<i>Product</i>&nbsp;follows JavaBean conventions and its properties are named the same as the defined CSV columns. Records disobeying the column definition are ignored. Consequently, I do not need to worry about the file's header and footer.<br /><br />With the transformation configuration out of the way, I turned my attention to running the transformation on the CSV file from my Java code and process the <i>Product</i> objects as they are instantiated and bound by Smooks:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=CsvToPojosTransformer.java"></script> <br /><h3><b>Trial II</b></h3><br />A more complex transformation task I gave to Smooks was to load file records, holding a variable number of columns, into a database. As in the previous task, this file had a header as well as a footer:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions.csv"></script>You'll observe in the sample CSV file that records could be one of three types as denoted by the first column: <i>TH</i>, <i>TB</i> or <i>TF</i>. The CSV reader, as it transforms and pushes records to the XML stream, can be customised such that it renames the&nbsp;<i>csv-record</i>&nbsp;holder to the record's primary column:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(1).xml"></script>As we'll see later, the above config permits Smooks to distinguish between the different record types. Given the sample file <i>transactions.csv</i>, the reader I've configured produces the following stream:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-xml-stream.xml"></script><i>UNMATCHED</i>&nbsp;elements represent the file's header and footer. A CSV record having <i>TH</i> in the first field will trigger the reader to create a <i>TH</i> element holding the other record fields. The same logic goes for&nbsp;<i>TB</i> and <i>TF</i>.<br /><br />Database visitors load the records. However, since these visitors are limited to binding data from POJOs, I first must turn the XML mapped records from the stream into said POJOs. The CSV reader doesn't know how to bind variable field records to POJOs so I configure the mapping myself:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(2).xml"></script>Given what we've learnt about Smooks, we can deduce what's happening here. The JavaBean visitor for lines 10 till 17 has a <b>selector</b> (i.e, <i>createOnElement</i>)&nbsp;for the element&nbsp;<i>TH</i>. A selector is&nbsp;a quasi XPath expression applied on XML elements as they come through the stream. On viewing&nbsp;<i>TH</i>, the visitor will:<br /><ol><li>Instantiate a <i>HashMap</i>.</li><br /><li>Iterate through the <i>TH</i> fragment. If an element inside the fragment matches the selector set in a <i>data</i> attribute, then (a) a map entry is created, (b) bound to the element content, and (c) put in the map.</li><br /><li>Add the map to the Smooks bean context which is identified by the name set in <i>beanID</i>. The map overwrites any previous map in the context with the same ID. This makes sense since we want to prevent objects from accumulating in memory.</li></ol>The database visitors reference the maps in the bean context:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(3).xml"></script>The insert statements are bound to the map entry values and are executed <b>after</b>&nbsp;the element, the <i>executeOnElement</i> selector points to, is processed. The next step is to configure a datasource for the database visitors (lines 47-49):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(4).xml"></script>Last but not least, the Java code to kick off the data load:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=CsvToDbTransformer.java"></script> <br /><h3> Trial III</h3><br />The next challenge for Smooks makes the previous ones look like child's play. The goal: transform an XML stream to a CSV file that is eventually uploaded to an FTP server. The input:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=accounts-stream.xml"></script>The desired output:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=accounts.csv"></script>Considering the CSV could be large in size, my requirement was for Smooks to write the transformed content to a <a href="http://docs.oracle.com/javase/8/docs/api/java/io/PipedOutputStream.html" target="_blank"><i>PipedOutputStream</i></a>. An FTP library would read from the <i>PipedOutputStream</i>'s connected <a href="http://docs.oracle.com/javase/8/docs/api/java/io/PipedInputStream.html" target="_blank"><i>PipedInputStream</i></a>, and write the streamed content to a file. To this end, I wrote the class running the transformation as follows:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=XmlToCsvTransformer(1).java"></script>My focus then turned to the XML-to-CSV mapping configuration. After deliberation, I reluctantly settled to use the&nbsp;<a href="http://freemarker.org/" target="_blank">FreeMarker</a> visitor for writing the CSV. I considered as an alternative to develop a visitor specialised for this type of transformation but time constraints made this unfeasible. The FreeMarker visitor, like the database one, cannot read directly off the XML stream. Instead, it can read from DOM and POJOs. So I decide to use the DOM visitor such that it creates DOMs from <i>record</i>&nbsp;elements found within the input stream:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(1).xml"></script>I then configured the FreeMarker visitor to apply the CSV template on seeing the element&nbsp;<i>record</i>&nbsp;in the stream:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(2).xml"></script>Below is a simplified version of what I had in real life in<i>&nbsp;account.ftl</i>&nbsp;(note the last line of the template must be a newline):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=account.ftl"></script>An additional complexity I had to consider were the CSV's header and footer. Apart from being structured differently than the rest of the records, the header had to contain the current date whereas, for the footer, the total record count. What I did for the header was to bind the current date from my Java code to Smooks's bean context (lines 27-30 and 38):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=XmlToCsvTransformer(2).java"></script>The date is then referenced from the Smooks config (lines 9-12):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(3).xml"></script>With respect to the above config, at the start of the XML stream, FreeMarker writes the header to the output stream (i.e., <i>PipedOutputStream</i>):<br /><br /><i>000000Card Extract &nbsp; </i>[current date]<br /><br /><i>&lt;?TEMPLATE-SPLIT-PI?&gt;</i>&nbsp;is an embedded Smooks instruction that applies&nbsp;<i>account.ftl</i>&nbsp;to <i>record</i> elements after the header.<br /><br />Adding the record count to the footer is just a matter of configuring the Calculator visitor to maintain a counter in the bean context and referencing that counter from the template:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(4).xml"></script> <br /><h3> Trial IV</h3><br />The final challenge Smooks had to go against was to read from a&nbsp;<i>java.util.Iterator</i>&nbsp;of maps and, like the previous task, write the transformed output to a stream in CSV format. Unlike the <i>InputStream</i>&nbsp;that Smooks read from the other tasks, Smooks doesn't have a reader that is capable of writing a properly structured XML doc from an iterator of maps. So I'm left with writing my own reader:<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=MapIteratorSourceReader.java"></script>The custom reader is hooked into Smooks as follows (line 5):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=map-iterator-to-csv.xml"></script>Finally, passing the iterator to Smooks for transformation consists of setting a <i>JavaSource</i> parameter, holding the iterator, on <i>filterSource(...)</i> &nbsp;(line 27):<br /><br /><script src="https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=MapIteratorToCsvTransformer.java"></script> <br /><div style="text-align: justify;"><span class="num" style="font-family: &quot;times&quot; , &quot;times new roman&quot; , serif;">1: The Smooks version I used was 1.5.2.</span></div><div style="text-align: justify;"><span class="num" style="font-family: &quot;times&quot; , &quot;times new roman&quot; , serif;">2: You might be wondering how I know for certain the XML document shown is the one actually produced by Smooks. I know because of Smooks's <a href="http://www.smooks.org/mediawiki/index.php?title=V1.5:Smooks_v1.5_User_Guide#Checking_the_Smooks_Execution_Process">HtmlReportGenerator</a> class.</span></div>
