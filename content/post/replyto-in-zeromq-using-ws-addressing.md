+++
title = "ReplyTo in ZeroMQ using WS-Addressing"
date = 2013-01-27T17:22:00Z
updated = 2013-02-05T19:42:25Z
tags = ["SOAP", "ReplyTo", "ØMQ", "WS-Addressing", "ZeroMQ"]
blogimport = true 
[author]
	name = "Claude"
	uri = "https://www.blogger.com/profile/06379003436141860057"
+++

In my <a href="http://opensourcesoftwareandme.blogspot.com/2013/01/soap-over-zeromq-with-apache-cxf.html" target="_blank">last post</a>, I mentioned how one could leverage SOAP along with WS-Addressing to implement the <a href="http://www.eaipatterns.com/ReturnAddress.html" target="_blank">return address pattern</a> in&nbsp;ØMQ&nbsp;(known in the JMS world as&nbsp;<i>ReplyTo</i>&nbsp;and in the MSMQ world as&nbsp;<i>ResponseQueue</i>). In this post, I'll go into more detail by giving a code example using <a href="https://github.com/claudemamo/cxf-rt-transports-zeromq" target="_blank">CXF's ØMQ transport</a>.<br /><br />Below is a WSDL that is similar in many respects to the WSDL of the previous post:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=hello_world_addr.wsdl"></script>Like the other WSDL, this one declares that the service has an operation named <i>sayHi</i>. It states that&nbsp;ØMQ&nbsp;is to be used for transporting the SOAP messages (line 29). Moreover, it declares the service and consumer communication parameters:&nbsp;<i>zmq:address;</i>&nbsp;<i>zmq:serviceConfig;</i>&nbsp;<i>zmq:clientConfig</i> (lines 43-45).&nbsp;<b>Unlike</b> the other WSDL, the socket types are <i>push</i> for the client and <i>pull</i> for the service. This means that communication between the client and service is one-way and therefore the client won't receive a reply, at least not on the same channel. Remember, since we're implementing return address, the service sends its reply onto a different channel.<br /><br />This is the shell command I entered for generating the SEI and proxy classes:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=generate-client.sh"></script>The <i>-asyncMethods</i> switch tells CXF's <i>wsdl2java</i> to generate, in the SEI, for each Web Service operation an asynchronous method in addition to a synchronous one. In the consumer implementation, I use the generated SEI:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=Client.java"></script><i>doOperation()&nbsp;</i>sequence of events is as follows:<br /><ol><li>Publishes the endpoint that processes the service's async reply (line 10).</li><br /><li>Creates a client that has WS-Addressing enabled (lines 13-14).</li><br /><li>Adds the <i>ReplyTo</i>&nbsp;element &nbsp;to the request's SOAP header (lines 17-18). The element contains the callback URL that the service will read in order to know to whom it should deliver its response and how it should deliver it.</li><br /><li>Calls asynchronously the SEI method&nbsp;<i>sayHiAsync()</i>&nbsp;(line 21).&nbsp;If the consumer invokes the synchronous&nbsp;method (i.e., <i>sayHi()</i>) instead of the async one, the&nbsp;consumer&nbsp;would block indefinitely after sending out the request because it will wait for a reply that it will never receive.</li></ol>The endpoint consuming the service's reply is a plain Web Service:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=Callback.java"></script>The callback terminates the program as soon as it processes the reply.<br /><br />I re-run <i>wsdl2java</i>&nbsp;to generate another SEI but using the following arguments:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=generate-server.sh"></script>I use the SEI generated from the above command to implement the service:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=GreeterImpl.java"></script>Nothing special about <i>GreeterImpl.java</i> except the <i>@Addressing</i> annotation. This annotation is required for CXF to process the request's WS-Addressing headers.<br /><br /><i>Main.java</i> triggers the server and consumer into action:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=Main.java"></script>The complete application is on&nbsp;<a href="https://github.com/claudemamo/zmq-replyto-soap" target="_blank">GitHub</a>.&nbsp;The instructions for running the demo are almost identical to the ones of the previous post. First enter the following Maven command from the project's root directory: <br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=build.sh"></script>Then run the demo using the <i>java</i> command:<br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=run.sh"></script>You should then get the following output: <br /><br /><script src="https://gist.github.com/claudemamo/4577639.js?file=gistfile1.txt"></script>
