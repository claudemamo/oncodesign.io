+++
title = "Mule meet ZeroMQ. ZeroMQ meet Mule."
date = 2012-06-24T19:17:00Z
updated = 2013-10-06T05:51:30Z
tags = ["Mule ZeroMQ Transport", "ØMQ", "Mule 3", "mule-transport-zeromq", "Mule", "ZeroMQ", "ZMQ"]
blogimport = true 
[author]
	name = "Claude"
	uri = "https://www.blogger.com/profile/06379003436141860057"
+++

<div style="text-align: justify;">These past few weeks I've been experimenting with <a href="http://www.zeromq.org/" target="_blank">ZeroMQ</a>&nbsp;(a.k.a. ØMQ or ZMQ). I like the idea of a library that provides you the building blocks for constructing your own messaging architecture. For example, we may want to send messages to an application that might be unavailable at times. In our system, losing some messages isn't the end of the world so we don't need to have a high degree of message reliability. A common solution for this type of problem&nbsp;is to introduce a message broker, such as ActiveMQ, and let the broker worry about making sure that messages are eventually delivered to the recipient. <br /><br /></div><div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-jvsiYKjXCGI/T-bQS0ma4VI/AAAAAAAAAA0/sxARfTv_WYU/s1600/broker.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-jvsiYKjXCGI/T-bQS0ma4VI/AAAAAAAAAA0/sxARfTv_WYU/s1600/broker.png" /></a></div><div class="separator" style="clear: both; text-align: center;"></div></div><div style="text-align: justify;"><br />The main disadvantage of this approach is that a broker adds another hop to the path of the message. Also, a broker is another point in your distributed system where things could go wrong.<br /><br />Another option is to let the sender ensure that the message gets delivered to the recipient. Since guaranteed message delivery isn't a requirement, we can afford to lose messages should the sender go down.<br /><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-Soh2smSKhXg/T-bP-1L4EtI/AAAAAAAAAAs/iSMt6QaW7oE/s1600/without-broker.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="111" src="http://4.bp.blogspot.com/-Soh2smSKhXg/T-bP-1L4EtI/AAAAAAAAAAs/iSMt6QaW7oE/s400/without-broker.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br /></div>Using <span class="Apple-style-span">ØMQ's </span><span class="Apple-style-span">asynchronous socket-like API, we can easily implement this scenario in a few minutes.</span><span class="Apple-style-span"> All we need is to submit the message to </span><span class="Apple-style-span">ØMQ, and </span><span class="Apple-style-span">ØMQ will deliver the message to the recipient on our behalf.</span><span class="Apple-style-span"> </span><span class="Apple-style-span">However, because </span><span class="Apple-style-span">ØMQ</span> has its own protocol, the library must be embedded within the sender and receiver applications.<br /><br /><span class="Apple-style-span"></span> <br /><div style="text-align: justify;"><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-yMEaJrA1NTw/T-bMKfhdCoI/AAAAAAAAAAc/wnRXJ9ARTek/s1600/with-zeromq.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-yMEaJrA1NTw/T-bMKfhdCoI/AAAAAAAAAAc/wnRXJ9ARTek/s1600/with-zeromq.png" /></a></div><br />This simple example just scratches the surface of what you can do with&nbsp;ØMQ. Real-world applications require the architecture to scale and&nbsp;ØMQ offers building blocks to tackle this challenge. Consult the&nbsp;<a href="http://zguide.zeromq.org/page:all" target="_blank">ØMQ guide</a> to learn more.<br /><br />How does <a href="http://www.mulesoft.org/" target="_blank">Mule</a>, an integration framework, fit in with&nbsp;ØMQ? Well, one simple use-case is that even though&nbsp;the back-end is talking in ØMQ, the outside world is speaking in a standard language such as HTTP. Mule can serve as the bridge between the outside world and the&nbsp;ØMQ back-end as shown below:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-1Qh9s-cMbck/T-bmdPfVmXI/AAAAAAAAABA/piTeyOZ-fdo/s1600/mule-zeromq.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-1Qh9s-cMbck/T-bmdPfVmXI/AAAAAAAAABA/piTeyOZ-fdo/s1600/mule-zeromq.png" /></a></div><br />On my <a href="https://github.com/claudemamo/mule-transport-zeromq/" target="_blank">GitHub page,</a> you'll find the first release of the Mule 3 ZeroMQ Transport for ZeroMQ 2.2. This transport frees you from having to know all the details of ØMQ's API. Furthermore, you don't need to worry about processing messages concurrently: the transport takes care of that.<br /><br /><script src="https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-request-response.xml"></script><span class="Apple-style-span">This snippet is all that it takes to implement the bridge in Mule. Those of you who are familiar with&nbsp;</span>Ø<span class="Apple-style-span">MQ API should find the <i>zeromq:outbound-endpoint</i> easy to understand. The outbound-endpoint is telling&nbsp;</span>Ø<span class="Apple-style-span">MQ to "connect" to the receiver 192.168.34.10 listening on port 9090. All of this will happen once, at initialisation time. At run-time, the outbound-endpoint will transform messages to arrays of bytes and send them off to the receiver. Replies are returned by the outbound-endpoint as arrays of bytes.&nbsp;</span><br /><br /><span class="Apple-style-span">The exchange pattern <i>request-response</i> is just one of several exchange patterns the&nbsp;</span>Ø<span class="Apple-style-span">MQ transport supports. What if we don't want to wait for the reply from the back-end? Just set the exchange pattern to <i>one-way</i>. </span>ØMQ folks, you may specify <i>push</i> instead of <i>one-way</i>. The same code is executed underneath.<br /><br /><script src="https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-one-way.xml"></script>Of course, it's quite possible that we have another Mule instance on the other end accepting Ø<span class="Apple-style-span">MQ messages as shown below:</span> <br /><br /><script src="https://gist.github.com/claudemamo/2941235.js?file=mule-config-inbound-request-response.xml"></script>Apart from different exchange patterns (see the project's <a href="https://github.com/claudemamo/mule-transport-zeromq/blob/master/README.md" target="_blank"><i>README</i></a> for the complete list of supported exchange patterns) and socket operations (i.e., <i>connect</i> and <i>bind</i>), the transport also supports multi-part messages. In the event a Ø<span class="Apple-style-span">MQ inbound-endpoint receives a multi-part message, a <i>java.util.List</i> is spit out. Each element in the list is a byte array representing a message part.&nbsp;</span><br /><br /><script src="https://gist.github.com/claudemamo/2941235.js?file=mule-config-inbound-multipart.xml"></script><span class="Apple-style-span">The outbound-endpoint works a little different when it comes to multi-part messages. To send a multi-part message, the <i>multipart</i> attribute must be set to true on the outbound-endpoint. Additionally, the message must be a <i>java.util.List</i> where each element represents a message part.</span><br /><span class="Apple-style-span"><br /><script src="https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-multipart.xml"></script>Let me know how you find this transport and how it may be improved. Code contributions are more than welcome :-). Future releases of the transport will support missing features such as durable sockets so keep an eye on the repo.</span></div>
